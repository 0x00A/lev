#!/usr/bin/env node

var repl = require('repl');
var fs = require('fs');
var path = require('path');
var levelup = require('levelup');
var argv = require('optimist').argv;

var levelcfg = {

  createIfMissing: argv.createIfMissing || false,
  errorIfExists: argv.errorIfExists || false, 
  compression: argv.compression || true,
  encoding: argv.encoding || 'utf8',
  keyEncoding: argv.keyEncoding || 'utf8',
};

var replcfg = {
  prompt: '>',
  input: process.stdin,
  output: process.stdout
};

var keypress = function keypress() {
  input.emit('keypress', '\r', { name: 'enter', ctrl: false, meta: false, shift: false });
};

var escapeRegExp = function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};

var output = replcfg.output;
var input = replcfg.input;

var cachedkeys = [];

fs.stat(argv.location || path.join('.', 'LOCK'), function(err) {

  var location;
  var commands = {};
  var formatting;
  
  var silentop;
  var lastopts;

  if (levelcfg.createIfMissing === false && err && err.errno === 34) {
    process.stderr.write('error. no leveldb found in this directory (try using `--location`).\r\n');
    process.exit(1);
  }
  else {
    location = argv.location || process.cwd();
  }

  levelup(location, levelcfg, function(err, db) {

    if (err) {
      return output.write(String(err));
    }

    commands.pwd = {

      description: 'Locaiton of the current database',
      cli: false,
      method: function() {
        return location;
      }
    };

    commands.readStream = {

      description: 'A readable stream of the full database.',
      usage: '',
      shorthand: 'r',
      cli: true,
      method: function(start, end, limit) {

        var opts = {};

        if (argv.r) {

          opts.start = argv.r;
          opts.end = argv._[0] || argv.start + '~';
          opts.limit = argv.limit || argv.l || -1;
          opts.reverse = argv.reverse || false;
        }
        else if (typeof arguments[0] === 'number') {

          limit = arguments[0];
          start = undefined;
          end = undefined;
        }
        else if (typeof arguments[0] === 'object') {

          opts = arguments[0];
        }
        else {

          opts = {
            start: start || argv.start,
            end: (end || argv.end || start + '~'),
            limit: (limit || argv.limit || 80)
          };
        }

        db.readStream(opts).on('data', function(data) {

            if (formatting) {
              output.write(data + '\r\n');
            }
            else {
              output.write(String(data));
            }
          })
          .on('end', function() { 

            keypress();
          })
        ;
      }
    };

    commands.get = {

      description: 'Fetch data from the store.',
      usage: '',
      shorthand: 'g',
      cli: true,
      method: function(key, cb) {

        key = key || argv.get || argv.g;

        if (!key) { 
          return new Error('missing argument'); 
        }

        db.get(key, function(err, value) {

          if (err) {
            output.write(err + '\r\n');
            return cb && cb(err);
          }
          if (formatting) {

            output.write(value + '\r\n');
            keypress();
          }
          else {
            output.write(String(value));
          }
          cb && cb(null, value);
        });
      }
    };

    commands.put = {

      description: 'Insert data into the store.',
      usage: '',
      shorthand: 'p',
      cli: true,
      method: function(key, value, cb) {

        key = key || argv.put || argv.p;
        value = value || argv._[0];

        if (!key) { 
          return new Error('missing argument'); 
        }

        db.put(key, value, function(err) {

          if (err) {
            output.write(err + '\r\n');
            return cb && cb(err);
          }

          silentop = true;
          commands.keys.method(lastopts);

          output.write('OK\r\n');
          keypress();
          return cb && cb(null);
        });
      }
    };

    commands.del = {

      description: 'Remove data from the store.',
      usage: '',
      shorthand: 'd',
      cli: true,
      method: function(key, opts, cb) {

        key = key || argv.del || argv.d;

        if (!key) { 
          return new Error('missing argument'); 
        }

        db.del(key, function(err) {
          if (err) {
            return cb && cb(err);
          }
          
          silentop = true;
          commands.keys.method(lastopts);

          output.write('OK\r\n');
          keypress();
          return cb && cb(null);
        });
      }
    };

    commands.keys = {
      
      description: 'A readable stream of all keys in the database',
      usage: '',
      shorthand: 'k',
      cli: true,
      method: function(opts) {

        //
        // TODO: should only cache if this is in the repl.
        //
        cachedkeys = [];
 
        if (typeof opts === 'number') {
          opts = { limit: opts };
        }
        else if (typeof opts === 'string') {
          opts = {
            start: opts,
            end: arguments[1] || opts + '~',
            limit: arguments[2] || -1
          }
        }
        else if (argv.k) {

          var opts = {};

          if (typeof argv.k === 'number') {
            opts.limit = argv.k;
          }
          else {
            opts.start = argv.k;
            opts.end = argv._[0] || opts.start + '~';
            opts.limit = argv._[1] || -1;
          }
        }

        lastopts = opts;

        db.keyStream(opts)
          .on('data', function (data) {

            cachedkeys.push(data);

            if (silentop) { 
              return silent = false; 
            }

            formatting
              ? output.write(data + '\r\n')
              : output.write(String(data))
            ;
          })
          .on('end', function() {

            if (silentop) { 
              return silent = false; 
            }
            keypress();
          })
        ;
      }
    };

    commands.approximateSize = {

      description: 'Get the approximate number of bytes of file system space used by the given range',
      usage: '',
      shorthand: 'a',
      cli: true,
      method: function(start, end, callback) {

        start = start || argv._[0] || ' ';
        end = end || argv._[1] || '~';

        callback = callback || function (err, size) { 

          if (err) {
            return output.write(err);
          }

          formatting
            ? output.write(size + '\r\n')
            : output.write(String(size))
          ;
        };

        db.approximateSize(start, end, callback);
      }
    };

    commands.values = {

      description: 'A readable stream of all values in the database',
      usage: '',
      shorthand: 'v',
      cli: true,
      method: function(opts) {

        if (argv.limit || argv.l) {
          opts = { limit: argv.limit || argv.l };
        }
        else if (typeof opts === 'number') {
          opts = { limit: opts };
        }

        db.valueStream(opts)
          .on('data', function (data) {

            if (truncate > -1 || (argv.tuncate && argv.truncate > -1)) {
              data = data.substr(0, truncate || argv.truncate);
            }

            formatting
              ? output.write(data + '\r\n')
              : output.write(String(data))
            ;
          })
          .on('end', function() {
            keypress();
          })
        ;
      }
    };

    commands.format = {
      description: 'Make nice(r) output to standard out.',
      usage: '',
      shorthand: 'f',
      cli: true,
      method: function(b) {
        return formatting = b || argv.format || argv.f;
      }
    };

    commands.help = {
      description: 'This help',
      usage: '',
      shorthand: 'h',
      cli: true,
      method: function(method) {

        output.write('\r\n');

        //
        // TODO: get individual help
        //

        var longestkey = 0, padding = ' ';

        for (var command in commands) {
          if (command.length > longestkey) {
            longestkey = command.length;
          }
        }

        while(longestkey) {
          padding += ' ';
          longestkey--;
        }

        var help = [];

        for (var command in commands) {
          var c = commands[command];
          var s = '  ';
          
          if (argv.help || argv.h) {
            if (!c.cli) {
              continue;
            }

            s = (c.shorthand && '-' + c.shorthand);
            command = '--' + command;
          }
          else {
            command = command + '()';
          }

          help.push([
            s,
            command + padding.slice(command.length-2),
            c.description
          ].join(' '));
        }

        output.write(help.join('\r\n') + '\r\n');
      }
    };

    var shorthandmap = {};
    var cliop;

    for (var command in commands) {
      var s = commands[command].shorthand;
      if (s) {
        shorthandmap[s] = command;
      }
    }

    //
    // test if this was meant to be executed from the commandline.
    //
    for (var command in argv) {

      var c;

      if (shorthandmap[command]) {
        commands[shorthandmap[command]].method();
        cliop = true;
      }
      else if (commands[command] && commands[command].cli) {
        commands[command].method();
        cliop = true;
      }
    }

    if (!cliop) {
      var r = repl.start(replcfg);
      
      for (var command in commands) {
        r.context[command] = commands[command].method;
      }

      var _complete = r.complete;
      var cmdRE = /\b(?:get|del|put|range)\s*\((?:['"])(.*)/;

      r.complete = function(line, callback) {

        var match = line.match(cmdRE);
        var filter = [];

        if (match) {
          if (cachedkeys.length === 0) {
            callback(null, [[], '']);
          }
          else {
            
            filter = cachedkeys.filter(function(e) {
              return e.match(new RegExp('^' + escapeRegExp(match[1]) + '(?:.*?)$'));
            });
          }

          var list = (filter.length > 0) ? filter : cachedkeys;
          return callback(null, [list, match[1]]);
        }
        _complete.apply(this, arguments);

      };
    }
  });
});
