#!/usr/bin/env node

var repl = require('repl');
var fs = require('fs');
var path = require('path');
var http = require('http');
var net = require('net');
var readline = require('readline');
var deleteRange = require("level-delete-range");

var levelup = require('levelup');
var argv = require('optimist').argv;

var levelcfg = {}; 
var replcfg = {};
var r; // repl instance.
var httpserver; 
var tcpserver;

try {

  var defaults = JSON.parse(fs.readFileSync(path.join(process.env['HOME'], '.lev'))) || {};

  levelcfg.createIfMissing = defaults.level.createIfMissing;
  levelcfg.errorIfExists = defaults.level.errorIfExists;
  levelcfg.compression = defaults.level.compression;
  levelcfg.encoding = defaults.level.encoding;
  levelcfg.keyEncoding = defaults.level.encoding;
}
catch(ex) {
  if (ex.name === 'SyntaxError') {
    console.log('error parsing settings file [%s]', ex.message);
  }
}

//
// take the take the cli argument, else the config file value, if none  use a default.
//
levelcfg.createIfMissing = argv.c || argv.createIfMissing || levelcfg.createIfMissing || false;
levelcfg.errorIfExists = argv.errorIfExists || levelcfg.errorIfExists || false;
levelcfg.compression = argv.compression || levelcfg.compression || true;
levelcfg.encoding = argv.encoding || levelcfg.encoding || 'utf8';
levelcfg.keyEncoding = argv.keyEncoding || levelcfg.keyEncoding || 'utf8';

if (argv.json) {
  levelcfg.encoding = 'json';
  levelcfg.keyEncoding = 'json';
}
else if (argv.utf8) {
  levelcfg.encoding = 'utf8';
  levelcfg.keyEncoding = 'utf8';
}

var write = function(d) {
  replcfg.output.write('\r\n' + d + '\r\n');
};

var escapeRegExp = function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};

var cachedkeys = [];
var databases = {};
var location = argv._[0];
var commands = {};

var ps;

if (location.length > 15) {
  ps = '...' + location.slice(-15);
}
else {
  ps = location;
}

replcfg = {
  prompt: ps + '>',
  input: process.stdin,
  output: process.stdout,
  ignoreUndefined: true
};

//
// if the user is not asking for help, ensure we are pointed at a valid
// location.
//
if (!argv.h && !argv.help) {

  fs.stat(location || path.join('.', 'LOCK'), function(err) {
    
    if (levelcfg.createIfMissing === false && err && err.errno === 34) {

      write(
        'no leveldb found in this directory (specify a directory' +
        ' or use `-c` to create a new database).'
      );
      process.exit(1);
    }
    else {
      location = location || process.cwd();
    }

    levelup(location, levelcfg, function(err, db) {

      if (err) {
        return write(String(err));
      }
      lev(db);
    });

  });
}
else {
  lev();
}

function lev(db) {

  if (db) {
    databases[location] = db;
  }

  var cleanup = function() {

    Object.keys(databases).forEach(function(name) {

      if (databases[name].close) {
        databases[name].close(function(err) {
          
          write('Attempting to close: ' + name);

          if (err) {
            write(err);
          }
        });        
      }
    });
  };

  process.on('exit', cleanup);
  process.on('SIGINT', cleanup);

  process.on('uncaughtException', function(err) {

    if (err.type === 'unexpected_token') {
      write('Encoding not compatible with ' + levelcfg.encoding);
    }
    else {
      write(err);
    }

    cleanup();
    process.exit(1);
  });

  commands.config = {

    description: 'Get the current configuration object',
    usage: [''],
    cli: false,
    method: function(encoding, includeKeys) {
      return levelcfg;
    }
  };

  commands.pwd = {

    description: 'Path of the current working database',
    usage: [''],
    cli: false,
    method: function() {
      return location;
    }
  };

  commands.create = {

    description: 'Return a new instance of leveldb',
    usage: [''],
    cli: false,
    method: function(loc, opts, callback) {

      opts = opts || {};

      opts.createIfMissing = true;

      location = loc;
      databases[loc] = levelup(loc, opts, callback);
      return Object.keys(databases);
    }
  };

  commands.close = {

    description: 'Close an instance of leveldb',
    usage: [''],
    cli: false,
    method: function() {

      db.close(function(err) {
        write(err || 'OK');
        r.displayPrompt();
      });

      return 'Closing...';
    }
  };

  commands.open = {

    description: 'Open an instance of leveldb',
    usage: [''],
    cli: false,
    method: function() {

      db.open(function(err) {
        write(!err ? 'OK' : err);
        r.displayPrompt();
      });
      return 'Opening...';
    }
  };

  commands.use = {

    description: 'Select the current database to use',
    usage: [
      'use([location])',
      'Specify the leveldb instance to use (provides directory tab completion).'
    ],
    cli: false,
    method: function(db) {

      if (!databases[db]) {
        return commands.create.method(db);
      }

      if (!db) {
        return db;
      }

      location = db;
      db = databases[db];
      return Object.keys(databases);
    }
  };

  commands.ls = {

    description: 'list of databases',
    usage: [''],
    cli: false,
    method: function(db) {

      return Object.keys(databases);
    }
  };

  commands.read = {

    description: 'Read a range of keys and values from the database.',
    usage: [''],
    shorthand: 'r',
    cli: true,
    method: function(start, end, limit) {

      cachedkeys = [];

      var opts = {};
      var quiet = false;

      //
      // the options may be specified from the cli.
      //
      if (argv.r) {

        if (argv._[1]) {
          opts.start = argv.r;
        }

        if (argv._[2]) {
          opts.end = argv._[2] || argv.start + '~';
        }

        if (argv.limit || argv.l) {
          opts.limit = argv.limit || argv.l;
        }

        if (argv.reverse) {
          opts.reverse = argv.reverse
        }
      }
      else if (typeof arguments[0] === 'boolean') {
        opts.values = false;
        quiet = true;
      }

      //
      // the first argument may be the limit
      //
      else if (typeof arguments[0] === 'number' && arguments[0] !== -1) {
        opts.limit = arguments[0];
      }

      //
      // the first argument may be an options object.
      //
      else if (typeof arguments[0] === 'object') {
        opts = arguments[0];
      }

      //
      // the options may be as specified in the method's signature
      //
      else {

        if (start || argv.start) {
          opts.start = start || argv.start;
        }

        if (end || argv.end) {
          opts.end = end || argv.end || opts.start + '~';
        }
      }

      if (typeof opts.limit === 'undefined' && 
        quiet === false && 
        start !== -1 &&
        !argv.r) {

        return write(
          'Result set may be quite large.\r\n' +
          'Consider specifying a limit or `-1` for all items.'
        );
      }

      var buffer = [];

      db.readStream(opts).on('data', function(data) {

        if (!data.key && !data.value || data.key) {
          cachedkeys.push(data.key || data);
        }

        buffer.push(data);

      })
      .on('end', function() {

        if (buffer.length && quiet === false) {
          write(JSON.stringify(buffer, 2, 2));
        }

        if (r) {
          r.displayPrompt();
        }
      });
    }
  };

  //
  // key and value methods parse their args the same way.
  //
  function keyValArgsParse(opts) {

    opts = opts || {};

    var cliargs = argv.k || argv.keys || argv.v || argv.value;

    if (typeof opts === 'number') {
      opts = { limit: opts };
    }
    else if (typeof opts === 'string') {
      opts = {
        start: opts,
        end: arguments[1] || opts + '~',
        limit: arguments[2] || -1
      }
    }
    else if (cliargs) {

      if (typeof cliargs === 'number') {
        opts.limit = cliargs;
      }
      else {

        opts.start = argv.k;
        opts.end = argv._[1] || opts.start + '~';
        opts.limit = argv._[1] || -1;
      }
    }
    return opts || {};
  }

  commands.keys = {
    
    description: 'Read a range of keys from the database.',
    usage: [''],
    shorthand: 'k',
    cli: true,
    method: function(opts) {

      opts = keyValArgsParse(opts);
      opts.values = false;
      opts.keys = true;

      commands.read.method(opts);
    }
  };

  commands.values = {

    description: 'Read a range of values from the database.',
    usage: [''],
    shorthand: 'v',
    cli: true,
    method: function(opts) {

      opts = keyValArgsParse(opts);
      opts.keys = false;
      opts.values = true;

      commands.read.method(opts);
    }
  };

  commands.get = {

    description: 'Fetch data from the store.',
    usage: [''],
    shorthand: 'g',
    cli: true,
    method: function(key, cb) {

      key = key || argv.get || argv.g;

      if (typeof key === 'string') {
        key = key.replace(/\r\n/g, '');
      }

      if (!key) { 
        return new Error('missing argument'); 
      }

      db.get(key, function(err, data) {

        if (err) {
          write(err);
          return cb && cb(err);
        }

        if (levelcfg.encoding === 'json') {
          data = JSON.stringify(data, true, 2);
        }
        else {
          data = String(data);
        }

        write(data);

        if (r) {
          r.displayPrompt();
          cb && cb(null, data);            
        }
      });
    }
  };

  commands.put = {

    description: 'Insert data into the store.',
    usage: [''],
    shorthand: 'p',
    cli: true,
    method: function(key, value, cb) {

      key = key || argv.put || argv.p;
      value = value || argv._[1];

      if (typeof value === 'string') {
        value = value.replace(/\r\n/g, '');
      }

      if (!key) { 
        return new Error('missing argument'); 
      }

      db.put(key, value, function(err) {

        if (err) {
          write(err);
          return cb && cb(err);
        }

        write('OK');

        if (r) {
          r.displayPrompt();
          
          //
          // refresh the cached keys.
          //
          commands.read.method(true);

          return cb && cb(null);          
        }
      });
    }
  };

  commands.del = {

    description: 'Remove data from the store.',
    usage: [''],
    shorthand: 'd',
    cli: true,
    method: function(key, opts, cb) {

      key = key || argv.del || argv.d;

      if (!key) { 
        return new Error('missing argument'); 
      }

      db.del(key, function(err) {
        if (err) {
          return cb && cb(err);
        }

        write('OK');
        
        if (r) {
          r.displayPrompt();

          //
          // refresh the cached keys.
          //
          commands.read.method(true);
          return cb && cb(null);            
        }
      });
    }
  };

  commands.delr = {
    description: 'Delete a range from the database.',
    usage: [
      'deleteRange(<start>, [end], [callback])',
      'Delete a range starting from <start> to [end].'
    ],
    shorthand: '',
    cli: true,
    method: function(start, end, cb) {

      if (!start) {
        return write('A start key must be specified.');
      }

      var opts = {};
      opts.start = start;

      if (end) {
        opts.end = end;
      }

      deleteRange(db, opts, function (err) {

        if (err && cb) {
          return cb(err);
        }

        if (r) {
          commands.read.method(true);
          return cb && cb(null);
        }
      });

    }
  };

  commands.size = {

    description: 'An approximate number of bytes of used by the given range.',
    usage: [''],
    shorthand: 'a',
    cli: true,
    method: function(start, end, cb) {

      start = start || argv._[1] || ' ';
      end = end || argv._[2] || '~';

      if (!cb) {
        cb = function (err, size) { 

          if (err) {
            return write(err);
          }

          write(size);
          
          if (r) {
            r.displayPrompt();
          }
        };
      }

      db.approximateSize(start, end, cb);
    }
  };

  commands.help = {
    description: 'This help',
    usage: [''],
    shorthand: 'h',
    cli: true,
    method: function(method) {

      if (method) {
        write(commands[method].usage.join('\r\n'));
      }

      //
      // TODO: get individual help
      //

      var longestkey = 0, padding = ' ';

      for (var command in commands) {
        if (command.length > longestkey) {
          longestkey = command.length;
        }
      }

      while(longestkey) {
        padding += ' ';
        longestkey--;
      }

      var help = [];

      for (var command in commands) {
        var c = commands[command];
        var s = '  ';
        
        if (argv.help || argv.h) {
          if (!c.cli) {
            continue;
          }

          if (c.shorthand === '') {
            s = '  ';
          }
          else {
            s = (c.shorthand && '-' + c.shorthand);
          }

          command = '--' + command;
        }
        else {
          command = command + '()';
        }

        help.push([
          s,
          command + padding.slice(command.length-2),
          c.description
        ].join(' '));
      }

      write(help.join('\r\n'));
    }
  };

  var shorthandmap = {};
  var cliop;

  for (var command in commands) {
    var s = commands[command].shorthand;
    if (s) {
      shorthandmap[s] = command;
    }
  }

  //
  // test if this was meant to be executed from the commandline.
  //
  for (var command in argv) {

    var c;

    if (shorthandmap[command]) {
      cliop = true;
      commands[shorthandmap[command]].method();
    }
    else if (commands[command] && commands[command].cli) {
      cliop = true;
      commands[command].method();
    }
  }

  if (!cliop) {
    
    r = repl.start(replcfg);

    // build a cache of the keys.
    commands.read.method(true);
    
    for (var command in commands) {
      r.context[command] = commands[command].method;
    }

    var _complete = r.complete;
    var cmdRE = /\b(?:get|del|put|range)\s*\((?:['"])(.*)/;
    var useRE = /\b(?:use)\s*\((?:['"])(.*)/;

    r.complete = function(line, callback) {

      var match = line.match(cmdRE);
      var use = line.match(useRE);
      var filter = [];

      if (use) {
        return _complete.call(this, 'require(\'' + use[1], arguments[1]);
      }

      else if (match) {

        if (cachedkeys.length === 0) {
          callback(null, [[], '']);
        }
        else {
          
          filter = cachedkeys.filter(function(e) {
            return e.match(new RegExp('^' + escapeRegExp(match[1]) + '(?:.*?)$'));
          });
        }

        var list = (filter.length > 0) ? filter : cachedkeys;
        return callback(null, [list, match[1]]);
      }
      _complete.apply(this, arguments);

    };
  }
}

