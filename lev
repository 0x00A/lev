#!/usr/bin/env node

var repl = require('repl');
var fs = require('fs');
var path = require('path');
var http = require('http');
var net = require('net');

var levelup = require('levelup');

var argv = require('optimist').argv;

var levelcfg = {}; 
var replcfg = {};
var r; // repl instance.
var formatting;
var httpserver; 
var tcpserver;

try {

  var defaults = JSON.parse(fs.readFileSync(path.join(process.env['HOME'], '.lev'))) || {};

  formatting = defaults.format;

  levelcfg.createIfMissing = defaults.level.createIfMissing;
  levelcfg.errorIfExists = defaults.level.errorIfExists;
  levelcfg.compression = defaults.level.compression;
  levelcfg.encoding = defaults.level.encoding;
  levelcfg.keyEncoding = defaults.level.encoding;
}
catch(ex) {
  if (ex.name === 'SyntaxError') {
    console.log('error parsing settings file [%s]', ex.message);
  }
}

//
// take the value from the config file, if none take the cli argument else use default.
//
levelcfg.createIfMissing = argv.c || argv.createIfMissing || levelcfg.createIfMissing || false;
levelcfg.errorIfExists = argv.errorIfExists || levelcfg.errorIfExists || false;
levelcfg.compression = argv.compression || levelcfg.compression || true;
levelcfg.encoding = argv.encoding || levelcfg.encoding || 'utf8';
levelcfg.keyEncoding = argv.keyEncoding || levelcfg.keyEncoding || 'utf8';

if (argv.json) {
  levelcfg.encoding = 'json';
  levelcfg.keyEncoding = 'json';
}
else if (argv.utf8) {
  levelcfg.encoding = 'utf8';
  levelcfg.keyEncoding = 'utf8';
}

replcfg = {
  prompt: '>',
  input: process.stdin,
  output: process.stdout
};

var write = function(d) {
  replcfg.output.write(d);
};

var escapeRegExp = function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
};


var cachedkeys = [];
var databases = {};
var OK = 'OK';

fs.stat(argv.location || path.join('.', 'LOCK'), function(err) {

  var location;
  var commands = {};
  
  var silentop;
  var lastopts;

  if (levelcfg.createIfMissing === false && err && err.errno === 34) {
    write('no leveldb found in this directory (specify a directory with `--location <dir>` or use `-c` to create).\r\n');
    process.exit(1);
  }
  else {
    location = argv.location || process.cwd();
  }

  levelup(location, levelcfg, function(err, db) {

    if (err) {
      return write(String(err));
    }

    databases[location] = db;

    var cleanup = function() {

      Object.keys(databases).forEach(function(name) {
        databases[name].close(function(err) {
          
          write('[attempting to close: ' + name + ']');

          if (err) {
            write(err);
          }
        });
      });
    };

    process.on('exit', cleanup);
    process.on('SIGINT', cleanup);

    process.on('uncaughtException', function(err) {
      cleanup();
      process.exit(1);
    });

    commands.pwd = {

      description: 'Path of the current working database',
      usage: [''],
      cli: false,
      method: function() {
        return location;
      }
    };

    commands.create = {

      description: 'Return a new instance of leveldb',
      usage: [''],
      cli: false,
      method: function(loc, opts, callback) {

        opts = opts || {};

        opts.createIfMissing = true;

        location = loc;
        databases[loc] = levelup(loc, opts, callback);
        return Object.keys(databases);
      }
    };

    commands.close = {

      description: 'Close an instance of leveldb',
      usage: [''],
      cli: false,
      method: function() {

        db.close(function(err) {
          write((err || 'OK') + '\r\n');
          r.displayPrompt();
        });

        return 'Closing...';
      }
    };

    commands.open = {

      description: 'Open an instance of leveldb',
      usage: [''],
      cli: false,
      method: function() {

        db.open(function(err) {
          write((!err ? 'OK' : err) + '\r\n');
          r.displayPrompt();
        });
        return 'Opening...';
      }
    };

    commands.use = {

      description: 'Select the current database to use',
      usage: [
        'use([location])',
        'Specify the leveldb instance to use (provides tab completion just like require).'
      ],
      cli: false,
      method: function(db) {

        if (!databases[db]) {
          return commands.create.method(db);
        }

        if (!db) {
          return db;
        }

        location = db;
        db = databases[db];
        return Object.keys(databases);
      }
    };

    commands.ls = {

      description: 'list of databases',
      usage: [''],
      cli: false,
      method: function(db) {

        return Object.keys(databases);
      }
    };

    commands.readStream = {

      description: 'A readable stream of the full database.',
      usage: [''],
      shorthand: 'r',
      cli: true,
      method: function(start, end, limit) {

        var opts = {};

        if (argv.r) {

          opts.start = argv.r;
          opts.end = argv._[0] || argv.start + '~';
          opts.limit = argv.limit || argv.l || -1;
          opts.reverse = argv.reverse || false;
        }
        else if (typeof arguments[0] === 'number') {

          limit = arguments[0];
          start = undefined;
          end = undefined;
        }
        else if (typeof arguments[0] === 'object') {

          opts = arguments[0];
        }
        else {

          opts = {
            start: start || argv.start,
            end: (end || argv.end || start + '~'),
            limit: (limit || argv.limit || 80)
          };
        }

        db.readStream(opts).on('data', function(data) {

          if (levelcfg.encoding === 'json') {
            data = JSON.stringify(data, true, 2);
          }
          else {
            data = String(data);
          }

          write(formatting ? data + '\r\n' : data);
        })
        .on('end', function() { 

          r.displayPrompt();
        })
        ;
      }
    };

    commands.get = {

      description: 'Fetch data from the store.',
      usage: [''],
      shorthand: 'g',
      cli: true,
      method: function(key, cb) {

        key = key || argv.get || argv.g;

        key = key.replace(/\r\n/g, '');

        if (!key) { 
          return new Error('missing argument'); 
        }

        db.get(key, function(err, data) {

          if (err) {
            write(err + '\r\n');
            return cb && cb(err);
          }

          if (levelcfg.encoding === 'json') {
            data = JSON.stringify(data, true, 2);
          }
          else {
            data = String(data);
          }

          write(formatting ? data + '\r\n' : data);
          r.displayPrompt();

          cb && cb(null, data);
        });
      }
    };

    commands.put = {

      description: 'Insert data into the store.',
      usage: [''],
      shorthand: 'p',
      cli: true,
      method: function(key, value, cb) {

        key = key || argv.put || argv.p;
        value = value || argv._[0];

        value = value.replace(/\r\n/g, '');

        if (!key) { 
          return new Error('missing argument'); 
        }

        db.put(key, value, function(err) {

          if (err) {
            write(err + '\r\n');
            return cb && cb(err);
          }

          silentop = true;
          commands.keys.method(lastopts);

          write(formatting ? 'OK\r\n' : 'OK');
          r.displayPrompt();
          return cb && cb(null);
        });
      }
    };

    commands.del = {

      description: 'Remove data from the store.',
      usage: [''],
      shorthand: 'd',
      cli: true,
      method: function(key, opts, cb) {

        key = key || argv.del || argv.d;

        if (!key) { 
          return new Error('missing argument'); 
        }

        db.del(key, function(err) {
          if (err) {
            return cb && cb(err);
          }
          
          silentop = true;
          commands.keys.method(lastopts);

          write(formatting ? 'OK\r\n' : 'OK');
          r.displayPrompt();
          return cb && cb(null);
        });
      }
    };

    commands.keys = {
      
      description: 'A readable stream of all keys in the database',
      usage: [''],
      shorthand: 'k',
      cli: true,
      method: function(opts) {

        //
        // TODO: should only cache if this is in the repl.
        //
        cachedkeys = [];
 
        if (typeof opts === 'number') {
          opts = { limit: opts };
        }
        else if (typeof opts === 'string') {
          opts = {
            start: opts,
            end: arguments[1] || opts + '~',
            limit: arguments[2] || -1
          }
        }
        else if (argv.k) {

          var opts = {};

          if (typeof argv.k === 'number') {
            opts.limit = argv.k;
          }
          else {
            opts.start = argv.k;
            opts.end = argv._[0] || opts.start + '~';
            opts.limit = argv._[1] || -1;
          }
        }

        lastopts = opts;

        db.keyStream(opts)
          .on('data', function (data) {

            cachedkeys.push(data);

            if (silentop) { 
              return silent = false; 
            }

            if (levelcfg.encoding === 'json') {
              data = JSON.stringify(data, true, 2);
            }
            else {
              data = String(data);
            }

            write(formatting ? data + '\r\n' : data);
          })
          .on('end', function() {

            if (silentop) { 
              return silent = false; 
            }
            r.displayPrompt();
          })
        ;

      }
    };

    commands.approximateSize = {

      description: 'An approximate number of bytes of used by the given range',
      usage: [''],
      shorthand: 'a',
      cli: true,
      method: function(start, end, callback) {

        start = start || argv._[0] || ' ';
        end = end || argv._[1] || '~';

        callback = callback || function (err, size) { 

          if (err) {
            return write(err);
          }

          write(formatting ? size + '\r\n' : String(size));
          r.displayPrompt();
        };

        db.approximateSize(start, end, callback);
      }
    };

    commands.values = {

      description: 'A readable stream of all values in the database',
      usage: [''],
      shorthand: 'v',
      cli: true,
      method: function(opts) {

        if (typeof opts === 'number') {
          opts = { limit: opts };
        }
        else if (typeof opts === 'string') {
          opts = {
            start: opts,
            end: arguments[1] || opts + '~',
            limit: arguments[2] || -1
          }
        }
        else if (argv.v) {

          var opts = {};

          if (typeof argv.v === 'number') {
            opts.limit = argv.v;
          }
          else {
            opts.start = argv.v;
            opts.end = argv._[0] || opts.start + '~';
            opts.limit = argv._[1] || -1;
          }
        }

        db.valueStream(opts)
          .on('data', function (data) {

            // if (truncate > -1 || (argv.tuncate && argv.truncate > -1)) {
            //   data = data.substr(0, truncate || argv.truncate);
            // }

            if (levelcfg.encoding === 'json') {
              data = JSON.stringify(data, true, 2);
            }
            else {
              data = String(data);
            }

            write(formatting ? data + '\r\n' : data);
          })
          .on('end', function() {
            
            r.displayPrompt();
          })
        ;
      }
    };

    commands.format = {
      description: 'Make nice(r) output to standard out.',
      usage: [''],
      shorthand: 'f',
      cli: true,
      method: function(b) {

        //
        // There might still be a bug with optimist's boolean settings
        // so this bit of code can go away after that gets fixed.
        //
        if (typeof b !== undefined) {

          return formatting = b;
        }
        else if (argv.format === 'false' || argv.f === 'false') {
          return formatting = false;
        }
        else if (argv.format || argv.f) {
          return formatting = true;
        }
        return formatting;
      }
    };

    commands.help = {
      description: 'This help',
      usage: [''],
      shorthand: 'h',
      cli: true,
      method: function(method) {

        write('\r\n');

        if (method) {
          write(commands[method].usage.join('\r\n'));
        }

        //
        // TODO: get individual help
        //

        var longestkey = 0, padding = ' ';

        for (var command in commands) {
          if (command.length > longestkey) {
            longestkey = command.length;
          }
        }

        while(longestkey) {
          padding += ' ';
          longestkey--;
        }

        var help = [];

        for (var command in commands) {
          var c = commands[command];
          var s = '  ';
          
          if (argv.help || argv.h) {
            if (!c.cli) {
              continue;
            }

            s = (c.shorthand && '-' + c.shorthand);
            command = '--' + command;
          }
          else {
            command = command + '()';
          }

          help.push([
            s,
            command + padding.slice(command.length-2),
            c.description
          ].join(' '));
        }

        write(help.join('\r\n') + '\r\n');
        return OK;
      }
    };

    var shorthandmap = {};
    var cliop;

    for (var command in commands) {
      var s = commands[command].shorthand;
      if (s) {
        shorthandmap[s] = command;
      }
    }

    //
    // test if this was meant to be executed from the commandline.
    //
    for (var command in argv) {

      var c;

      if (shorthandmap[command]) {
        commands[shorthandmap[command]].method();
        cliop = true;
      }
      else if (commands[command] && commands[command].cli) {
        commands[command].method();
        cliop = true;
      }
    }

    if (!cliop) {
      
      r = repl.start(replcfg);
      
      for (var command in commands) {
        r.context[command] = commands[command].method;
      }

      var _complete = r.complete;
      var cmdRE = /\b(?:get|del|put|range)\s*\((?:['"])(.*)/;
      var useRE = /\b(?:use)\s*\((?:['"])(.*)/;

      r.complete = function(line, callback) {

        var match = line.match(cmdRE);
        var use = line.match(useRE);
        var filter = [];

        if (use) {
          return _complete.call(this, 'require(\'' + use[1], arguments[1]);
        }

        else if (match) {
          if (cachedkeys.length === 0) {
            callback(null, [[], '']);
          }
          else {
            
            filter = cachedkeys.filter(function(e) {
              return e.match(new RegExp('^' + escapeRegExp(match[1]) + '(?:.*?)$'));
            });
          }

          var list = (filter.length > 0) ? filter : cachedkeys;
          return callback(null, [list, match[1]]);
        }
        _complete.apply(this, arguments);

      };
    }
  });
});